---
layout: post-journal
title: Schema Design
date:   2020-04-13 09:00:11
tag: 
categories: interview
excerpt: 
permalink: /schema
comments: false

---


# Schema Design Theory

There are three types of relationships between entities:
- 1 to N (Example: A status message and comments on that status)
- N to 1 (Example: A status and its author)
- N to N (Example: A status and its tags)

In the case of a 1-to-N relationshop (a tree like structure), typically the entire tree is loaded as part of the queries, and joins are not need (queries like give all status messages corredponding to a particular comment do not exist).

In the other two cases, we can store the relationship in a denormalized form (e.g. store author name in every status, or array of tags within status), as in the case of a 1-to-N relationship. This would avoid joins. However, this causes duplication and will require extra work at the time of writing to ensure that data is consistent.

To avoid having to ensure consistency on every write, and get the other benefits of ormalizations (single source of truth), we can store the entities in separate tables emulate the joins in application code (by multiple roundtrip queries to the db).

Here we have two options:

- Two Table: Normalize with a second table and store the foreign key (e.g store author name) in one of the tables. 
- Three Table: Normalize further and store the relationship in a mapping table. In this case, the entities do not "know" about each other, except for the relationship in the mapping table. To populate queries, "give all tags of a particular status" or "give all statuses of a particular tag", we would need to emulate two joins. 

The data always tends to become more interconnected (move towards N-N) as application complexity increases, suggesting a three table solution.

