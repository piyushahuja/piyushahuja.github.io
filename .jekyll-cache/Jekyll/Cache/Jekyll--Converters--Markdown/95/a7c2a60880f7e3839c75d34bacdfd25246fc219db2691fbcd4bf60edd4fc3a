I"x<h1 id="what-is-docker">What is Docker?</h1>

<p>Docker is a form of OS-level virtualisation whose purpose is, to quote:</p>
<blockquote>
  <p>Package up code and all its dependencies so the application runs quickly and reliably from one computing environment to another</p>
</blockquote>

<hr />

<h1 id="why-docker">Why Docker?</h1>

<ul>
  <li>
    <p><strong>Speed</strong>: isolated, consistent and repeatable environments
for your developers to fire up a new version of the application that a collogue may have written requires muddling around in Git and using branches – this interrupts work flows and can lead to lose of work if “git stash” isn’t used right. With a container: they just run it.</p>
  </li>
  <li>
    <p><strong>Portability</strong>: Docker images define abstract and immutable run time environment independent of the underlying hardware platform and packages it into a well defined and efficient image specification. With Dockerhub, we have a global distribution network
First up: portability and allowing anyone, on any hardware, and any OS to run the application with a single command. All they need to do is install Docker and “docker run” will do the rest. With a TAR file based deployment, they need TAR, they need to know how-to deploy the application and manage the files; they may need some runtime on their system like Ruby, Python or NodeJS; and they cannot restrict the resources the application is using…</p>
  </li>
  <li>
    <p><strong>Simplifies your infrastructure requirements</strong>
you can restrict the resources the application is using inside of a container much easier than you can with one that is not.</p>
  </li>
  <li>
    <p><strong>Automation</strong> is first class citizen: Dockerfile, DockerCompose
one final point here: Docker Compose. You’re missing out on a lot of free stuff here. It’s so easy to write a Docker Compose file that brings up everything needed by the application - databases, caches, mocked APIs - allowing anyone in your organisation to bring up the application on their laptop and play with it, including the CEO, DBAs, QA, the receptionist. </p>
  </li>
</ul>

<p>Example: You don’t have to do these things (installing build tools, dependencies to build an application) on every new deployment! Instead you can build the applicationone and distribute it as an “executable” (without the build tools and dependencies)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Source Openrc-hgi.sh
Install python3
Install pip
Install setuptools wheel 
Pip install -r requirements.txt (openstack, dateutil, json,….)
Npm install (vue, bootstrapvue, …)
</code></pre></div></div>
<hr />

<h1 id="cheatsheet">Cheatsheet</h1>

<p><strong>For debugging</strong></p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># You can see a list of your running containers with the command, docker ps, just as you would in Linux.</span>
docker ps

journalctl <span class="nt">-u</span> docker.service | <span class="nb">tail</span> <span class="nt">-n</span> 50 

<span class="c"># to get a bash shell in a container </span>
docker exec <span class="nt">-it</span> &lt;container name&gt; /bin/bash 

<span class="c"># Example:  to get environmental variables</span>
docker <span class="nb">exec </span>container bash <span class="nt">-c</span> <span class="s1">'echo "$ENV_VAR"'</span>
docker <span class="nb">exec </span>container <span class="nb">printenv </span>VARIABLE

docker inspect &lt;container name&gt;

<span class="c"># You can display the long-form Id for a container with the command:</span>
docker inspect <span class="nt">--format</span> <span class="s1">'{{ .Id }}&gt;'</span> &lt;container name&gt;

<span class="c"># in a swarm </span>
docker service logs —details <span class="nt">--tail</span> 10 &lt;service name&gt;
docker service ps <span class="nt">--no-trunc</span>
docker service ps my-ngx <span class="c"># returns a task id</span>
<span class="c"># to get the container id</span>
docker inspect <span class="nt">-f</span> <span class="s2">"{{.Status.ContainerStatus.ContainerID}}"</span> &lt;task_id&gt; 

<span class="c"># exec inside a swarm service</span>

docker <span class="nb">exec</span> <span class="nt">-it</span> <span class="si">$(</span>docker ps <span class="nt">--filter</span> <span class="s2">"name=my-service."</span> <span class="nt">-q</span><span class="si">)</span> <span class="nb">cat</span> /run/secrets/my-service-secret


</code></pre></div></div>

<p><strong>For Cleanup</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># This will remove all stopped containers and should work on all platforms the same way.</span>
docker container prune

<span class="c"># To  clean up all unused containers, networks, images (both dangling and unreferenced), and optionally, volumes, in one command.will delete ALL unused data (i.e., in order: containers stopped, volumes without containers and images with no containers).</span>
docker system prune 

</code></pre></div></div>
<hr />

<p><strong>Useful Reads</strong></p>

:ET