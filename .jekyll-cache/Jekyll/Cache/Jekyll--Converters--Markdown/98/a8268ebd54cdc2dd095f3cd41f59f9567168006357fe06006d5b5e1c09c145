I"R
<p>The Problem: Alice has to send information to Bob. But the transfer should achieve the following:</p>
<ul>
  <li>It should be tamper-proof. If modified it should be detected by Bob</li>
  <li>It should be private or encrypted. No one but Bob can read it. Bob should be able to decrypt it.</li>
  <li>It should be collission resistant, i.e. brute force methods should not be able to replicate it.</li>
  <li>It should be fixed length? compressed? anthing else?</li>
</ul>

<p><strong>Checksums</strong> Checksum as a person’s full name: Eubediah Q. Horsefeathers. It’s a shortcut to uniqueness that’s fast and simple, but easy to forge, because security isn’t really the point of naming.</p>

<p><strong>Hashing</strong> The core purpose of hashing is to create a fingerprint of data to assess data integrity.
To qualify as a cryptographic hash function, a hash function must be pre-image resistant and collision resistant.</p>

<p>Given a message, you run it through the checksum algorithm, which the recipient knows. The recipient also receives the checksum through some independent source. If any single bit of the message was modified, you’d know.</p>

<p>Checksums need not themselves contain the message, so they can be publicly displa</p>

<p><strong>Hash Functions</strong>: MD5, SHA1, SHA256
Hash functions are a way to make your message tamper-proof . What makes them tampter-proof? The property that even a sligh change in input changes the output quite radically.</p>

<p>On the other hand:</p>
<ol>
  <li>Secure hashes are designed to be tamper-proof: changes its output radically with tiny single bit changes to the input data (MD5 has since been broken and vulnerable to tampering. SHA-1 isn’t great)</li>
  <li>Secure hashes are designed to be slow. The faster you can calculate the hash, the more viable it is to use brute force to mount attacks.</li>
</ol>

<p>You don’t walk up to someone and demand their fingerprints to prove they are who they say they are. Names are just convenient disambiguators, a way of quickly determining who you’re talking to for social reasons, not absolute proof of identity. </p>

<p>yed, and also made to have an output of fixed length.</p>

<p>Given a checksum algorithm and a checksum, can we find the original message? This is not possible, as a given checksum can correspond to many different inputs; even though collission is rare.</p>

<p>Checksums are fast</p>

<p>Hash functions are one-way functions whose inverse is difficult to calculate.</p>

<p>Terms to understand: SHA1, SHA256, ROT13, B64 encoding, BCrypt, RSA, Diffie Helman, PGP, Public/Private keys</p>

:ET