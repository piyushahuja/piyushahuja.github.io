I"M<hr />

<p>A <strong>program</strong> (or a task or thread of execution) is very general thing - a set of ordered instructions for the CPU to carry out.</p>

<p>A <strong>process</strong> is an executing instance of a program. As an implementation detail, it is a (collection of) thread of execution and other context, such as <strong>address space</strong> and <strong>file descriptor table.</strong></p>

<p><strong>unix implementation details</strong></p>

<p>Unix supports the notion of a <strong>current working directory</strong> for each process, maintained as part of the process state. This allows users to refer to files by their relative pathnames, which are interpreted relative to the current directory. Unix guarantees that every process has a unique identifier called the <strong>process ID</strong>. The process ID is always a non-negative integer. Similar to files, each process has one <strong>owner</strong> and <strong>group</strong>, and the owner and group permissions are used to determine which files and devices the process can open. Most processes also have <strong>a parent process</strong> that started them. </p>

<p><strong>File descriptors</strong> are normally small non-negative integers that the kernel uses to identify the files being accessed by a particular process.  Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that is used to read or write the file. (Sockets are based on a very similar mechanism i.e. socket descriptors).</p>

<p>A <strong>shell</strong> is a program (on Linux, typically written in C) that provides an interface to handle processes.</p>

<p>A (running) shell is a process but not all processes are shells. Sourcing a script will execute the commands in the current shell process, whereas executing a script will spawn a new shell process and execute the commands there (though it might be a child process).</p>

<p>An interactive shell (<code class="language-plaintext highlighter-rouge">sh</code>, <code class="language-plaintext highlighter-rouge">dash</code>, <code class="language-plaintext highlighter-rouge">bash</code>, <code class="language-plaintext highlighter-rouge">zsh</code>) interpets (compile source code into OS-readable binary on the fly) the commands you are typing in the terminal window, for example <code class="language-plaintext highlighter-rouge">ls</code>, <code class="language-plaintext highlighter-rouge">cat</code> and <code class="language-plaintext highlighter-rouge">date</code> (these are not shells but executable binaries). You launch an interactive shell by logging into a terminal emulator.</p>

<p>All running applications and daemons are processes. The only thing running which is not a process is the kernel (including kernel threads).</p>

<hr />

<p><strong>Process Lifecycle</strong></p>

<p>A process may start other processes (e.g. by making the <code class="language-plaintext highlighter-rouge">fork()</code> system call, which uses clone(), and then the exec() call to replace the clone); these new processes will belong to the same process group as the parent unless other action is taken.</p>

<p>Each process may also have a “controlling terminal”, which starts off the same as its parent.</p>

<p>The kernel, at least on Unix like OSes is launching one (or more) initial hand crafted processes, usually called init. These processes are the parents of a whole hierarchy of other processes.</p>

<p>The init process is normally started when the Kernel calls a certain filename – often found in <code class="language-plaintext highlighter-rouge">/etc/rc</code> or <code class="language-plaintext highlighter-rouge">/etc/inittab</code> – but this location can change based on OS. Normally this process sets the path, checks the file system, initializes serial ports, sets the clock, and more. Finally, the last thing the init process handles is starting up all the other background processes necessary for your operating system to run properly – and it runs them as daemons. Typically, all of these daemon scripts exist in /etc/init.d/; it’s conventional to end all of the daemon executables with the letter d (such as httpd, sshd, mysqld, etc.) – so you might think that this directory is named as such because of that, but it’s actually just a common unix convention to name directories that have multiple configuration files with a .d suffix.   </p>

<p>Traditionally in Unix, the only way to create a process is to create a copy of the existing process and to go from there. This practice – known as process forking – involves duplicating the existing process to create a child process and making an exec system call to start another program. We get the phrase “process forking” because fork is an actual C method in the Unix standard library which handles creating new processes in this manner. The process that calls the fork command will be considered the parent process of the newly created child process. The child process is nearly identical to the parent process, with a few differences such as different process IDs and parent process IDs, no shared memory locks, no shared async I/O, and more. </p>

<p>A process may create another thread that shares its address space.</p>

<hr />

<p><a href="http://www.programmerinterview.com/data-structures/difference-between-stack-and-heap/">Stack and Heap</a></p>

<hr />

<p><strong>OS distributions</strong></p>

<p>An OS distribution has an OS kernel which interacts with utilities packaged with it. Compiling the software and making them work with one another is the job of the distribution.  Some Linux distributions are intended for desktop computers, some for servers without a graphical interface, and others for special uses, such as home theater PCs, supercomputers, POS systems or embedded systems.</p>

<p>For example, the Linux kernel can be packaged with GNU shell utilities. The terminal and many of the commands we use on it are not part of the kernel, but of the Utilities.</p>

<p>Utilities might include:</p>

<ul>
  <li>desktop server</li>
  <li>desktop environment<sup id="fnref:desktop" role="doc-noteref"><a href="#fn:desktop" class="footnote" rel="footnote">1</a></sup></li>
</ul>

<ul>
  <li>system services (Red Hat Linux has a built-in tool called Lokkit for configuring the firewall capabilities)</li>
  <li>graphical program (e.f. Red Hat graphical installer called Anaconda)</li>
  <li>package managers (Red Hat was the first to use rpm)</li>
  <li>configuration utilities</li>
  <li>GNU shell utilities</li>
</ul>

<hr />

<p><strong>Job</strong></p>

<p>A shell that provides an interface to handle processes. It does so with the help of an abstraction call <strong>jobs</strong>.</p>

<p>Any process you interactively start that doesn’t detach from the terminal (ie, not a daemon) is a job.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:desktop" role="doc-endnote">
      <p>an implementation of the desktop metaphor made of a bundle of programs running on top of a computer operating system that share a common graphical user interface (GUI), sometimes described as a graphical shell.  Desktop GUIs help the user to easily access and edit files, while they usually do not provide access to all of the features found in the underlying operating system. Instead, the traditional command-line interface (CLI) is still used when full control over the operating system is required.  typically consists of icons, windows, toolbars, folders, wallpapers and desktop widgets (see Elements of graphical user interfaces and WIMP). GUI might also provide drag and drop functionality. aims to be an intuitive way for the user to interact with the computer using concepts which are similar to those used when interacting with the physical world, such as buttons and windows. <a href="#fnref:desktop" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET